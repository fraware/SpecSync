const { WebClient } = require('@slack/web-api');

class SlackAlerts {
  constructor() {
    this.slack = null;
    this.channel = process.env.SLACK_CHANNEL || '#specsync';
    this.botToken = process.env.SLACK_BOT_TOKEN;
    this.silencedAlerts = new Map(); // Track silenced alerts
    this.threadTimestamps = new Map(); // Track thread timestamps for proof failures
  }

  /**
   * Initialize Slack client
   */
  initialize() {
    if (this.botToken) {
      this.slack = new WebClient(this.botToken);
    } else {
      console.warn('SLACK_BOT_TOKEN not configured - Slack alerts disabled');
    }
  }

  /**
   * Enhanced Prompt 4.1 ‚Äî Spec Drift Alert
   * Goal: Notify relevant channel only on actionable drift.
   * Inputs: drift_events.json, CODEOWNERS mapping.
   * Explicit Outputs: Actionable alert with Review and Silence buttons
   */
  async sendDriftAlert(driftEvent) {
    if (!this.slack) {
      console.log('Slack not configured, skipping drift alert');
      return;
    }

    // Check if this alert is silenced
    const alertKey = `drift:${driftEvent.functionName}:${driftEvent.module}`;
    if (this.isAlertSilenced(alertKey)) {
      console.log(`Drift alert silenced for ${driftEvent.functionName}`);
      return;
    }

    const message = this.formatDriftMessage(driftEvent);
    
    try {
      const result = await this.slack.chat.postMessage({
        channel: this.channel,
        text: message.text,
        blocks: message.blocks,
        unfurl_links: false
      });

      console.log(`Drift alert sent: ${result.ts}`);
      return result;
    } catch (error) {
      console.error('Failed to send drift alert:', error);
      throw error;
    }
  }

  /**
   * Enhanced format drift alert message with actionable buttons
   * @param {Object} driftEvent - Drift event object
   * @returns {Object} Formatted message
   */
  formatDriftMessage(driftEvent) {
    const severityEmoji = {
      high: 'üî¥',
      medium: 'üü°',
      low: 'üü¢'
    };

    const severityColor = {
      high: '#dc3545',
      medium: '#ffc107',
      low: '#28a745'
    };

    const text = `${severityEmoji[driftEvent.severity]} Drift detected in \`${driftEvent.functionName}\` (module ${driftEvent.module}).\nReason: ${driftEvent.reason}`;

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${severityEmoji[driftEvent.severity]} Spec Drift Detected`,
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Function:*\n\`${driftEvent.functionName}\``
          },
          {
            type: 'mrkdwn',
            text: `*Module:*\n${driftEvent.module}`
          },
          {
            type: 'mrkdwn',
            text: `*Severity:*\n${driftEvent.severity.toUpperCase()}`
          },
          {
            type: 'mrkdwn',
            text: `*Author:*\n${driftEvent.author}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Reason:*\n${driftEvent.reason}`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Commit:*\n<https://github.com/company/repo/commit/${driftEvent.commit}|${driftEvent.commit}>`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Review',
              emoji: true
            },
            style: 'primary',
            url: `https://github.com/company/repo/pull/1234#specsync-proofcheck`
          },
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Silence 24h',
              emoji: true
            },
            action_id: 'silence_drift_alert',
            value: JSON.stringify({
              alertKey: `drift:${driftEvent.functionName}:${driftEvent.module}`,
              duration: 24 * 60 * 60 * 1000 // 24 hours in milliseconds
            })
          }
        ]
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `Alert ID: drift:${driftEvent.functionName}:${driftEvent.module} | Generated by SpecSync`
          }
        ]
      }
    ];

    return { text, blocks };
  }

  /**
   * Enhanced Prompt 4.2 ‚Äî Proof Failure Alert
   * Goal: Immediate red alert on CI proof failure.
   * Inputs: GitHub Action failure payload.
   * Explicit Outputs: Red alert with View Logs button and thread updates
   */
  async sendProofFailureAlert(proofFailure) {
    if (!this.slack) {
      console.log('Slack not configured, skipping proof failure alert');
      return;
    }

    const message = this.formatProofFailureMessage(proofFailure);
    
    try {
      const result = await this.slack.chat.postMessage({
        channel: this.channel,
        text: message.text,
        blocks: message.blocks,
        unfurl_links: false
      });

      console.log(`Proof failure alert sent: ${result.ts}`);
      
      // Store thread timestamp for future updates
      this.storeThreadTimestamp(proofFailure.prNumber, result.ts);
      
      return result;
    } catch (error) {
      console.error('Failed to send proof failure alert:', error);
      throw error;
    }
  }

  /**
   * Enhanced format proof failure alert message with actionable buttons
   * @param {Object} proofFailure - Proof failure object
   * @returns {Object} Formatted message
   */
  formatProofFailureMessage(proofFailure) {
    const text = `üî¥ Proof failed for PR #${proofFailure.prNumber}.\nFunction: ${proofFailure.functionName}\nLean error: ${proofFailure.error}`;

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üî¥ Proof Failure Alert',
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*PR:*\n#${proofFailure.prNumber}`
          },
          {
            type: 'mrkdwn',
            text: `*Function:*\n\`${proofFailure.functionName}\``
          },
          {
            type: 'mrkdwn',
            text: `*Repository:*\n${proofFailure.repository}`
          },
          {
            type: 'mrkdwn',
            text: `*Branch:*\n${proofFailure.branch}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Error:*\n\`\`\`${proofFailure.error}\`\`\``
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Theorem:*\n\`${proofFailure.theorem}\``
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Logs',
              emoji: true
            },
            url: proofFailure.logsUrl
          },
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Retry Proof',
              emoji: true
            },
            url: `https://github.com/${proofFailure.repository}/actions/workflows/lean4-ci.yml`
          }
        ]
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `Failed at ${new Date(proofFailure.timestamp).toLocaleString()} | Generated by SpecSync`
          }
        ]
      }
    ];

    return { text, blocks };
  }

  /**
   * Store thread timestamp for future updates
   * @param {string} prNumber - PR number
   * @param {string} threadTs - Thread timestamp
   */
  storeThreadTimestamp(prNumber, threadTs) {
    if (!this.threadTimestamps) {
      this.threadTimestamps = new Map();
    }
    this.threadTimestamps.set(prNumber, threadTs);
  }

  /**
   * Get thread timestamp for PR
   * @param {string} prNumber - PR number
   * @returns {string|null} Thread timestamp
   */
  getThreadTimestamp(prNumber) {
    return this.threadTimestamps ? this.threadTimestamps.get(prNumber) : null;
  }

  /**
   * Enhanced handle interactive messages with improved error handling
   * @param {Object} payload - Slack interactive message payload
   */
  async handleInteractiveMessage(payload) {
    if (payload.type === 'block_actions') {
      for (const action of payload.actions) {
        if (action.action_id === 'silence_drift_alert') {
          await this.handleSilenceAlert(action.value, payload);
        }
      }
    }
  }

  /**
   * Enhanced handle silence alert action with confirmation
   * @param {string} value - JSON string with alert details
   * @param {Object} payload - Slack payload
   */
  async handleSilenceAlert(value, payload) {
    try {
      const { alertKey, duration } = JSON.parse(value);
      
      // Add to silenced alerts
      this.silencedAlerts.set(alertKey, {
        silencedAt: Date.now(),
        expiresAt: Date.now() + duration
      });

      // Send confirmation message
      await this.slack.chat.postEphemeral({
        channel: payload.channel.id,
        user: payload.user.id,
        text: `‚úÖ Alert silenced for 24 hours: ${alertKey}`
      });

      console.log(`Alert silenced: ${alertKey}`);
    } catch (error) {
      console.error('Error handling silence alert:', error);
    }
  }

  /**
   * Check if an alert is silenced
   * @param {string} alertKey - Alert key
   * @returns {boolean} Is silenced
   */
  isAlertSilenced(alertKey) {
    const silenced = this.silencedAlerts.get(alertKey);
    if (!silenced) return false;

    // Check if silence has expired
    if (Date.now() > silenced.expiresAt) {
      this.silencedAlerts.delete(alertKey);
      return false;
    }

    return true;
  }

  /**
   * Clean up expired silenced alerts
   */
  cleanupSilencedAlerts() {
    const now = Date.now();
    for (const [key, silenced] of this.silencedAlerts.entries()) {
      if (now > silenced.expiresAt) {
        this.silencedAlerts.delete(key);
      }
    }
  }

  /**
   * Send thread update for proof status changes
   * @param {string} threadTs - Thread timestamp
   * @param {Object} statusUpdate - Status update object
   */
  async sendThreadUpdate(threadTs, statusUpdate) {
    if (!this.slack) return;

    const message = this.formatStatusUpdateMessage(statusUpdate);
    
    try {
      await this.slack.chat.postMessage({
        channel: this.channel,
        thread_ts: threadTs,
        text: message.text,
        blocks: message.blocks
      });
    } catch (error) {
      console.error('Failed to send thread update:', error);
    }
  }

  /**
   * Format status update message
   * @param {Object} statusUpdate - Status update object
   * @returns {Object} Formatted message
   */
  formatStatusUpdateMessage(statusUpdate) {
    const emoji = statusUpdate.success ? '‚úÖ' : '‚ùå';
    const text = `${emoji} Proof ${statusUpdate.success ? 'passed' : 'failed'}: ${statusUpdate.functionName}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${emoji} *Proof ${statusUpdate.success ? 'Passed' : 'Failed'}*\nFunction: \`${statusUpdate.functionName}\``
        }
      }
    ];

    if (statusUpdate.details) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Details:*\n${statusUpdate.details}`
        }
      });
    }

    return { text, blocks };
  }

  /**
   * Send coverage summary alert
   * @param {Object} coverageSummary - Coverage summary object
   */
  async sendCoverageSummary(coverageSummary) {
    if (!this.slack) return;

    const message = this.formatCoverageSummaryMessage(coverageSummary);
    
    try {
      await this.slack.chat.postMessage({
        channel: this.channel,
        text: message.text,
        blocks: message.blocks
      });
    } catch (error) {
      console.error('Failed to send coverage summary:', error);
    }
  }

  /**
   * Format coverage summary message
   * @param {Object} coverageSummary - Coverage summary object
   * @returns {Object} Formatted message
   */
  formatCoverageSummaryMessage(coverageSummary) {
    const { coverage, totalFunctions, coveredFunctions, failedProofs } = coverageSummary;
    
    const emoji = coverage >= 70 ? 'üü¢' : coverage >= 50 ? 'üü°' : 'üî¥';
    const text = `${emoji} Coverage Summary: ${coverage}% (${coveredFunctions}/${totalFunctions} functions)`;

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${emoji} Spec Coverage Summary`,
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Coverage:*\n${coverage}%`
          },
          {
            type: 'mrkdwn',
            text: `*Functions:*\n${coveredFunctions}/${totalFunctions}`
          },
          {
            type: 'mrkdwn',
            text: `*Failed Proofs:*\n${failedProofs}`
          },
          {
            type: 'mrkdwn',
            text: `*Status:*\n${coverage >= 70 ? '‚úÖ Good' : coverage >= 50 ? '‚ö†Ô∏è Warning' : '‚ùå Critical'}`
          }
        ]
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Dashboard',
              emoji: true
            },
            url: `${process.env.DASHBOARD_URL}/coverage`
          }
        ]
      }
    ];

    return { text, blocks };
  }

  /**
   * Send drift resolution alert
   * @param {Object} driftResolution - Drift resolution object
   */
  async sendDriftResolution(driftResolution) {
    if (!this.slack) return;

    const message = this.formatDriftResolutionMessage(driftResolution);
    
    try {
      await this.slack.chat.postMessage({
        channel: this.channel,
        text: message.text,
        blocks: message.blocks
      });
    } catch (error) {
      console.error('Failed to send drift resolution:', error);
    }
  }

  /**
   * Format drift resolution message
   * @param {Object} driftResolution - Drift resolution object
   * @returns {Object} Formatted message
   */
  formatDriftResolutionMessage(driftResolution) {
    const text = `‚úÖ Drift resolved: ${driftResolution.functionName} in ${driftResolution.module}`;

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚úÖ Drift Resolved',
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Function:*\n\`${driftResolution.functionName}\``
          },
          {
            type: 'mrkdwn',
            text: `*Module:*\n${driftResolution.module}`
          },
          {
            type: 'mrkdwn',
            text: `*Resolved by:*\n${driftResolution.resolvedBy}`
          },
          {
            type: 'mrkdwn',
            text: `*Resolution:*\n${driftResolution.resolution}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Previous Issue:*\n${driftResolution.previousIssue}`
        }
      }
    ];

    return { text, blocks };
  }

  /**
   * Get notification statistics
   * @returns {Object} Notification stats
   */
  getNotificationStats() {
    return {
      totalAlerts: this.silencedAlerts.size,
      silencedAlerts: Array.from(this.silencedAlerts.keys()),
      slackConfigured: !!this.slack
    };
  }

  /**
   * Test Slack connectivity
   * @returns {Promise<boolean>} Connection status
   */
  async testConnectivity() {
    if (!this.slack) {
      return { connected: false, error: 'Slack not configured' };
    }

    try {
      const result = await this.slack.auth.test();
      return {
        connected: true,
        team: result.team,
        user: result.user,
        channel: this.channel
      };
    } catch (error) {
      return {
        connected: false,
        error: error.message
      };
    }
  }
}

module.exports = { SlackAlerts }; 